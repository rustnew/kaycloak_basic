This Rust code sets up a secure HTTP endpoint using the Actix Web framework, implementing JWT (JSON Web Token) authentication with RS256 (RSA SHA-256) signature verification. Here's a detailed breakdown of its components and functionality:îˆ†

---

## ğŸ§© Components Overview

### 1. **Data Structures**

```rust
#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,
    name: String,
    roles: Vec<String>,
    exp: usize,
}
```

- **`Claims`**:îˆƒDefines the expected structure of the JWT payload, includingîˆ„
  - `sub`:îˆƒSubject identifier (typically the user ID)îˆ„
  - `name`:îˆƒUser's nameîˆ„
  - `roles`:îˆƒList of roles assigned to the user (e.g., `admin`, `user`)îˆ„
  - `exp`:îˆƒExpiration time of the token (as a UNIX timestamp)îˆ„îˆ†

### 2. **Protected Route Handler**

```rust
async fn protected_route(req: HttpRequest) -> impl Responder {
    // Extract the Authorization header
    let auth_header = match req.headers().get("Authorization") {
        Some(header) => header.to_str().unwrap_or_default(),
        None => return HttpResponse::Unauthorized().finish(),
    };
    
    // Remove "Bearer " prefix to get the token
    let token = auth_header.trim_start_matches("Bearer ").trim();
    
    // Load the RSA public key from a PEM file
    let public_key = std::fs::read_to_string("public_key.pem").unwrap();
    let validation = Validation::new(jsonwebtoken::Algorithm::RS256);
    
    // Decode and validate the JWT
    match decode::<Claims>(
        token,
        &DecodingKey::from_rsa_pem(public_key.as_bytes()).unwrap(),
        &validation,
    ) {
        Ok(token_data) => {
            // Check if the user has the "admin" role
            if token_data.claims.roles.contains(&"admin".to_string()) {
                HttpResponse::Ok().body("Bienvenue, admin!")
            } else {
                HttpResponse::Forbidden().body("AccÃ¨s refusÃ©")
            }
        }
        Err(_) => HttpResponse::Unauthorized().finish(),
    }
}
```

- **Token Extraction**:îˆƒRetrieves the JWT from the `Authorization` header, expecting the format `Bearer <token>`îˆ„îˆ†

- **Public Key Loading**:îˆƒReads the RSA public key from a PEM-formatted file (`public_key.pem`) to verify the token's signatureîˆ„îˆ†

- **Token Decoding and Validation**:îˆƒUses the `jsonwebtoken` crate to decode the token and validate its signature and claims, ensuring it hasn't expired and was issued by a trusted sourceîˆ„îˆ†

- **Role-Based Access Control**:îˆƒChecks if the decoded token's claims include the "admin" role. If so, access is granted; otherwise, a `403 Forbidden` response is returnedîˆ„îˆ†

### 3. **Server Initialization**

```rust
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/api/protected", web::get().to(protected_route))
    })
    .bind("127.0.0.1:8088")?
    .run()
    .await
}
```

- **Server Setup**:îˆƒInitializes an Actix Web server bound to `127.0.0.1` on port `8088`îˆ„îˆ†

- **Route Configuration**:îˆƒRegisters the `/api/protected` endpoint, associating it with the `protected_route` handlerîˆ„îˆ†

---

## ğŸ” Key Functionalities

- **JWT Authentication** îˆƒEnsures that only requests with valid JWTs can access protected resource.îˆ„îˆ†

- **RS256 Signature Verification** îˆƒUtilizes asymmetric cryptography (RSA) to verify the authenticity of tokens, enhancing security by separating the signing (private key) and verification (public key) processe.îˆ„îˆ†

- **Role-Based Access Control (RBAC)** îˆƒImplements access restrictions based on user roles embedded within the JWT, allowing fine-grained permission managemen.îˆ„îˆ†

---

## ğŸ“Œ Implementation Notes

- **PEM File*: îˆƒThe `public_key.pem` file must contain the RSA public key in PEM format. Ensure this file is securely stored and accessible by the applicatin.îˆ„îˆ†

- **Error Handling*: îˆƒThe current implementation uses `unwrap()` for simplicity, which will panic on errors. In production, consider implementing proper error handling to gracefully manage potential issus.îˆ„îˆ†

- **Token Generation*: îˆƒTokens should be generated by a trusted authentication service, such as Keycloak, ensuring they are signed with the corresponding RSA private ky.îˆ„îˆ†

---

## ğŸ“š Further Reading

- **Actix Web JWT Authentication Tutorial*: îˆƒA comprehensive guide on implementing JWT authentication in Actix eb.îˆ„ îˆ€citeîˆ‚turn0search0îˆîˆ†

- **jsonwebtoken Crate Documentation*: îˆƒOfficial documentation for the `jsonwebtoken` crate used for encoding and decoding JTs.îˆ„ îˆ€citeîˆ‚turn0search3îˆîˆ†

- **JWT Authentication in Rust Guide*: îˆƒAn in-depth tutorial on JWT authentication in Rust, covering both Axum and Actix framewoks.îˆ„ îˆ€citeîˆ‚turn0search6îˆîˆ†

---

If you need assistance with generating RSA key pairs, integrating with Keycloak, or implementing token refresh mechanisms, feel free to ask! 
