This Rust code sets up a secure HTTP endpoint using the Actix Web framework, implementing JWT (JSON Web Token) authentication with RS256 (RSA SHA-256) signature verification. Here's a detailed breakdown of its components and functionality:

---

## 🧩 Components Overview

### 1. **Data Structures**

```rust
#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,
    name: String,
    roles: Vec<String>,
    exp: usize,
}
```

- **`Claims`**:Defines the expected structure of the JWT payload, including
  - `sub`:Subject identifier (typically the user ID)
  - `name`:User's name
  - `roles`:List of roles assigned to the user (e.g., `admin`, `user`)
  - `exp`:Expiration time of the token (as a UNIX timestamp)

### 2. **Protected Route Handler**

```rust
async fn protected_route(req: HttpRequest) -> impl Responder {
    // Extract the Authorization header
    let auth_header = match req.headers().get("Authorization") {
        Some(header) => header.to_str().unwrap_or_default(),
        None => return HttpResponse::Unauthorized().finish(),
    };
    
    // Remove "Bearer " prefix to get the token
    let token = auth_header.trim_start_matches("Bearer ").trim();
    
    // Load the RSA public key from a PEM file
    let public_key = std::fs::read_to_string("public_key.pem").unwrap();
    let validation = Validation::new(jsonwebtoken::Algorithm::RS256);
    
    // Decode and validate the JWT
    match decode::<Claims>(
        token,
        &DecodingKey::from_rsa_pem(public_key.as_bytes()).unwrap(),
        &validation,
    ) {
        Ok(token_data) => {
            // Check if the user has the "admin" role
            if token_data.claims.roles.contains(&"admin".to_string()) {
                HttpResponse::Ok().body("Bienvenue, admin!")
            } else {
                HttpResponse::Forbidden().body("Accès refusé")
            }
        }
        Err(_) => HttpResponse::Unauthorized().finish(),
    }
}
```

- **Token Extraction**:Retrieves the JWT from the `Authorization` header, expecting the format `Bearer <token>`

- **Public Key Loading**:Reads the RSA public key from a PEM-formatted file (`public_key.pem`) to verify the token's signature

- **Token Decoding and Validation**:Uses the `jsonwebtoken` crate to decode the token and validate its signature and claims, ensuring it hasn't expired and was issued by a trusted source

- **Role-Based Access Control**:Checks if the decoded token's claims include the "admin" role. If so, access is granted; otherwise, a `403 Forbidden` response is returned

### 3. **Server Initialization**

```rust
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/api/protected", web::get().to(protected_route))
    })
    .bind("127.0.0.1:8088")?
    .run()
    .await
}
```

- **Server Setup**:Initializes an Actix Web server bound to `127.0.0.1` on port `8088`

- **Route Configuration**:Registers the `/api/protected` endpoint, associating it with the `protected_route` handler

---

## 🔐 Key Functionalities

- **JWT Authentication** Ensures that only requests with valid JWTs can access protected resource.

- **RS256 Signature Verification** Utilizes asymmetric cryptography (RSA) to verify the authenticity of tokens, enhancing security by separating the signing (private key) and verification (public key) processe.

- **Role-Based Access Control (RBAC)** Implements access restrictions based on user roles embedded within the JWT, allowing fine-grained permission managemen.

---

## 📌 Implementation Notes

- **PEM File*: The `public_key.pem` file must contain the RSA public key in PEM format. Ensure this file is securely stored and accessible by the applicatin.

- **Error Handling*: The current implementation uses `unwrap()` for simplicity, which will panic on errors. In production, consider implementing proper error handling to gracefully manage potential issus.

- **Token Generation*: Tokens should be generated by a trusted authentication service, such as Keycloak, ensuring they are signed with the corresponding RSA private ky.

---

## 📚 Further Reading

- **Actix Web JWT Authentication Tutorial*: A comprehensive guide on implementing JWT authentication in Actix eb. citeturn0search0

- **jsonwebtoken Crate Documentation*: Official documentation for the `jsonwebtoken` crate used for encoding and decoding JTs. citeturn0search3

- **JWT Authentication in Rust Guide*: An in-depth tutorial on JWT authentication in Rust, covering both Axum and Actix framewoks. citeturn0search6

---

If you need assistance with generating RSA key pairs, integrating with Keycloak, or implementing token refresh mechanisms, feel free to ask! 
